# Docker CVE Resolution Strategy

## The Challenge

Without building Docker images, we cannot determine exact package versions for commands like:
```dockerfile
RUN apt-get install -y nginx  # What version? Depends on repo state!
```

## Recommended Multi-Tier Approach

### Tier 1: Static Analysis with Smart Defaults (Fast)
```python
class DockerVersionResolver:
    def __init__(self):
        # Maintain distro → package → version mappings
        self.version_cache = {
            "ubuntu:20.04": {
                "nginx": "1.18.0-0ubuntu1.2",
                "postgresql": "12+214ubuntu0.1",
                "redis": "5:5.0.7-2",
            },
            "alpine:3.14": {
                "nginx": "1.20.2-r0",
                "postgresql": "13.8-r0",
                "redis": "6.2.6-r0",
            }
        }
    
    def resolve_package_version(self, package, base_image):
        """Best effort version resolution without building."""
        distro_cache = self.version_cache.get(base_image, {})
        return distro_cache.get(package, "unknown")
```

**Benefits:**
- Instant results
- No build required
- Good enough for common packages

**Limitations:**
- Cache maintenance required
- May be outdated
- Misses edge cases

### Tier 2: Repository Query API (Accurate for Current State)
```python
class DistroRepositoryQuerier:
    def query_ubuntu_package(self, package, ubuntu_version):
        """Query Ubuntu package repository for current version."""
        # Use launchpad.net API or packages.ubuntu.com
        response = requests.get(
            f"https://api.launchpad.net/ubuntu/{ubuntu_version}/{package}"
        )
        return response.json()["version"]
    
    def query_alpine_package(self, package, alpine_version):
        """Query Alpine package repository."""
        # Use pkgs.alpinelinux.org API
        response = requests.get(
            f"https://pkgs.alpinelinux.org/packages?name={package}&branch=v{alpine_version}"
        )
        return parse_alpine_version(response.text)
```

**Benefits:**
- Current version info
- No build required
- Accurate for "latest"

**Limitations:**
- Network dependency
- API rate limits
- Point-in-time accuracy only

### Tier 3: Selective Build Analysis (Most Accurate)
```python
class SelectiveDockerBuilder:
    def analyze_with_build(self, dockerfile_path, risk_assessment):
        """Selectively build images based on risk assessment."""
        
        if risk_assessment == "trusted":
            # Build in isolated environment
            image_id = self.build_in_sandbox(dockerfile_path)
            packages = self.extract_packages_from_image(image_id)
            self.cleanup(image_id)
            return packages
        
        elif risk_assessment == "semi-trusted":
            # Build only base layers
            base_image = self.extract_base_image(dockerfile_path)
            return self.get_base_image_packages(base_image)
        
        else:  # untrusted
            # Static analysis only
            return self.static_parse_only(dockerfile_path)
    
    def extract_packages_from_image(self, image_id):
        """Extract complete package list from built image."""
        # Using docker API to get package list without running
        commands = {
            "debian": "dpkg -l",
            "alpine": "apk info -v",
            "rhel": "rpm -qa"
        }
        
        # Create container without starting it
        container = docker.create_container(image_id, entrypoint="/bin/sh")
        
        # Copy package database
        package_db = docker.copy_from_container(container, "/var/lib/dpkg/status")
        
        return parse_package_database(package_db)
```

### Tier 4: Layer Caching & Intelligence
```python
class DockerLayerCache:
    def __init__(self):
        self.layer_cache = {}  # layer_hash → packages
        self.base_image_cache = {}  # image:tag → packages
    
    def get_packages_for_dockerfile(self, dockerfile):
        """Use caching to avoid rebuilds."""
        
        packages = []
        
        for instruction in parse_dockerfile(dockerfile):
            if instruction.type == "FROM":
                # Check base image cache
                if instruction.image in self.base_image_cache:
                    packages.extend(self.base_image_cache[instruction.image])
                else:
                    # Fetch from registry or vulnerability DB
                    base_packages = self.fetch_base_image_packages(instruction.image)
                    self.base_image_cache[instruction.image] = base_packages
                    packages.extend(base_packages)
            
            elif instruction.type == "RUN":
                # Check if we've seen this exact command before
                layer_hash = hash(instruction.command + str(packages))
                if layer_hash in self.layer_cache:
                    packages.extend(self.layer_cache[layer_hash])
                else:
                    # Need to resolve versions
                    new_packages = self.resolve_run_packages(instruction, packages)
                    self.layer_cache[layer_hash] = new_packages
                    packages.extend(new_packages)
        
        return packages
```

## Recommended Implementation Path

### Phase 1: Enhanced Static Analysis
1. Implement distro-specific version caches
2. Add confidence scoring to results
3. Flag "unknown" versions clearly

### Phase 2: Repository Integration
1. Add Ubuntu/Debian package API client
2. Add Alpine package API client  
3. Cache query results with TTL

### Phase 3: Base Image Intelligence
1. Integrate with vulnerability databases that track base images
2. Use Docker Hub API to get image manifests
3. Cache base image package lists

### Phase 4: Selective Building (Optional)
1. Implement sandboxed build environment
2. Add risk assessment for Dockerfiles
3. Extract packages without running containers

## CVE Mapping with Confidence Scores

```python
class DockerCVEMapper:
    def map_package_to_cves(self, package, resolution_method):
        """Map packages to CVEs with confidence scores."""
        
        cves = []
        
        if package.version == "unknown":
            # Can't map accurately
            return [{
                "severity": "UNKNOWN",
                "confidence": 0.1,
                "note": "Package version could not be determined"
            }]
        
        # Map based on resolution method
        confidence = {
            "explicit_version": 1.0,      # nginx=1.18.0-0ubuntu1.2
            "cache_lookup": 0.8,          # From version cache
            "repo_query": 0.9,            # From package repo API
            "base_image_manifest": 0.95,  # From image manifest
            "built_image": 1.0,           # From actual build
            "static_guess": 0.3           # Best guess
        }[resolution_method]
        
        # Query CVE databases
        raw_cves = self.query_cve_databases(package)
        
        # Add confidence scores
        for cve in raw_cves:
            cve["confidence"] = confidence
            cve["resolution_method"] = resolution_method
            cves.append(cve)
        
        return cves
```

## Practical Recommendations

### For CI/CD Pipelines:
```yaml
# .github/workflows/docker-scan.yml
docker-security-scan:
  strategy:
    matrix:
      mode: [static, enhanced, build]
  steps:
    - name: Quick Static Scan
      if: matrix.mode == 'static'
      run: sca-scanner --docker-mode static .
      
    - name: Enhanced Scan with Repo Queries  
      if: matrix.mode == 'enhanced'
      run: sca-scanner --docker-mode enhanced --cache-ttl 24h .
      
    - name: Full Build Scan (Weekly)
      if: matrix.mode == 'build' && github.event_name == 'schedule'
      run: sca-scanner --docker-mode build --sandbox .
```

### For Security Teams:
1. Use static analysis for rapid feedback
2. Use enhanced mode for daily scans
3. Use build mode for critical applications
4. Always review low-confidence findings

### For Developers:
1. Pin versions in Dockerfiles when possible
2. Use specific base image tags (not :latest)
3. Document security assumptions
4. Provide SBOM when possible

## Conclusion

Perfect CVE detection for Docker requires building images, but practical security scanning can achieve good results through:

1. Smart static analysis with version caching
2. Repository API integration
3. Base image intelligence
4. Selective building for critical cases

The key is to provide confidence scores and be transparent about limitations.